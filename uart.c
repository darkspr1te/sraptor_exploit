#define STM32F1
#define STM32F103xB
#include "stm32f1xx.h"

void set_system_clock_to_25Mhz(void)
{
	// Enable HSE
	RCC->CR |= (1 << 16);
	// Wait untill HSE settles down
	while (!(RCC->CR & (1 << 17)));
	// Choose HSE as the system clock
	RCC->CFGR |= (1 << 0);
}

void set_system_clock_to_8Mhz(void) {
    // Enable HSE
    RCC->CR |= (1 << 16);
    // Wait untill HSE settles down
    while (!(RCC->CR & (1 << 17)));
    // Choose HSE as the system clock
    RCC->CFGR |= (1 << 0);
}
void Aset_system_clock_to_72Mhz(void) {
    // set the number of wait states for Flash 
    FLASH->ACR = 0x12;
    // Enable HSE
    RCC->CR |= (1 << 16);
    // Wait untill HSE settles down
    while (!(RCC->CR & (1 << 17))) ;
    // Set PLL1 multiplication factor to 9
    RCC->CFGR |= (0b0111 << 18);
    // select PLL input clock from PREDIV1
    RCC->CFGR |= (1 << 16);
    // Set APB2 to 36MHz
    RCC->CFGR |= 0b100 << 11;
    // Set APB1 to 36MHz
    RCC->CFGR |= 0b100 << 8;
    // Enable PLL
    RCC->CR |= (1 << 24);
    // Wait untill PLL settles down
    while (!(RCC->CR & (1 << 25))) ;
    // Select the PLL as the system clock
    RCC->CFGR |= (0b10 << 0);
}
/*
 * By default 8 MHz internal clock is used (HSI)
 * Set up as 72 MHz (HSE-PLL)
 *
 * 25M ->   /5    ->   *8    ->   /5    ->   *9   -> 72 MHz
 * HSE -> PreDiv2 -> Pll2Mul -> PreDiv1 -> PllMul -> System Clock
 * Set Prediv1Src = PLL2, Set PllSrc as Prediv1
 *
 * 25 MHz External clock is selected as the source clock (HSE)
 * It is divided by 5 with PreDiv2, then muliplied by 8 with Pll2Mul
 * Then it is divided by 5 with PreDiv1, then multiplied by 9 with PllMul
 * Then choose Pll as the clock source
 */
 //pll mul 8 , 
 /*
void set_system_clock_to_72Mhz(void)
{
	// Necessary wait states for Flash for high speeds
	FLASH->ACR = 0x12;
	// Enable HSE
	RCC->CR |= (1 << 16);
	// Wait untill HSE settles down
	while (!(RCC->CR & (1 << 17)));
	// Set PREDIV2 division factor to 5
	RCC->CFGR2 |= (0b0100 << 4);
	// Set PLL2 multiplication factor to 8
	RCC->CFGR2 |= (0b0110 << 8);
	// Enable PLL2
	RCC->CR |= (1 << 16);
	// Wait untill PLL2 settles down
	while (!(RCC->CR & (1 << 27)));
	// Set PLL2 as PREDIV1 clock source
	RCC->CFGR2 |= (1 << 16);
	// Set PREDIV1 division factor to 5
	RCC->CFGR2 |= (0b0100 << 0);
	// Select Prediv1 as PLL source
	RCC->CFGR |= (1 << 16);
	// Set PLL1 multiplication factor to 9
	RCC->CFGR |= (0b0111 << 18);
	// Set APB1 to 36MHz
	RCC->CFGR |= 1 << 10;
	// Enable PLL
	RCC->CR |= (1 << 24);
	// Wait untill PLL settles down
	while (!(RCC->CR & (1 << 25)));
	// Finally, choose PLL as the system clock
	RCC->CFGR |= (0b10 << 0);
}
*/

/*************************************************
* Main code starts from here
*************************************************/
#define SystemCoreClock_24 24000000
#define SystemCoreClock_8   8000000
#define SystemCoreClock_72 64000000

int notmain ( void )
{
	// Copy LMA to VMA for data section
	//copy_data();

	// Set clock to 72 MHz
	//Aset_system_clock_to_72Mhz();

 // set the number of wait states for Flash 
    FLASH->ACR = 0x12;
    // Enable HSE
    RCC->CR |= (1 << 16);
    // Wait untill HSE settles down
    while (!(RCC->CR & (1 << 17))) ;
    // Set PLL1 multiplication factor to 9
    RCC->CFGR |= (0b0111 << 18);
    // select PLL input clock from PREDIV1
    RCC->CFGR |= (1 << 16);
    // Set APB2 to 36MHz
    RCC->CFGR |= 0b100 << 11;
    // Set APB1 to 36MHz
    RCC->CFGR |= 0b100 << 8;
    // Enable PLL
    RCC->CR |= (1 << 24);
    // Wait untill PLL settles down
    while (!(RCC->CR & (1 << 25))) ;
    // Select the PLL as the system clock
    RCC->CFGR |= (0b10 << 0);


	//uint32_t i = 0;
	// Enable alternate function clock. Bit 0 in RCC APB2ENR register
	RCC->APB2ENR |= (1 << 0);
	// Enable GPIOA clock. Bit 2 in RCC APB2ENR register
	RCC->APB2ENR |= (1 << 2);
	// Enable clock for UART1 clock. Bit 14 in RCC APB2ENR register
	RCC->APB2ENR |= (1 << 14);

	// Make GPIOA Pin 9,10 (PA9, PA10) alternate-function output (0b1010)
	GPIOA->CRH &= 0xFFFFF00F;
	GPIOA->CRH |= 0x00000BB0;

	// Enable USART
	USART1->CR1 |= (1 << 13);
	// Word length - leave default (8 data)
	USART1->CR1 |= (0 << 12);
	// Number of stop bits - leave default (1 stop)
	USART1->CR2 |= (0b00 << 12);
	// Baud rate
	// BRR should be 468.75 for 9600 baud rate
	// Thus manista is 468 (0x1d4) and fraction is 12 (0xc) (12/16 is .75)
	// Making it 0x1d4c
	//((SystemCoreClock*2)/9600)
	//int BRR_VALUE = ((SystemCoreClock_8*2)/9600)
	//USART1->BRR = 0x1d4c;
	//USART1->BRR = ((SystemCoreClock_8*2)/9600);//currently running at 57600
	
	USART1->BRR = 0x271;
	
	//USART1->BRR = 0x1d4;
	// Transmitter enable
	USART1->CR1 |= (1 << 3);
	// Receiver enable
	USART1->CR1 |= (1 << 2);
	
	
 for (int addr=0x8000000;addr <= 0x803e800;addr++)
	 
 //for (int addr=0x8000000;addr <= 0x8000010;addr++)
 {
	 USART1->DR = *((uint16_t*) addr );
	 while(!(USART1->SR & (1 << 6)));
 }
 
	
	// Should never reach here
	return (0);
}
